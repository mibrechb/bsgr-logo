<!doctype html>
<html lang='de-CH'>
  <head>
    <meta charset='utf-8' />
    <meta name='viewport' content='width=device-width, initial-scale=1' />
    <title>BSG Reinach Logo – Farbvarianten</title>
    <style>
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        margin: 24px;
      }
      .wrap {
        display: grid;
        grid-template-columns: 1fr 360px;
        gap: 24px;
        align-items: start;
        max-width: 1200px;
      }
      .card {
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        padding: 16px;
      }
      h1 {
        font-size: 18px;
        margin: 0 0 10px 0;
      }
      h2 {
        font-size: 14px;
        margin: 16px 0 8px 0;
      }
      .muted {
        color: #6b7280;
        font-size: 13px;
        line-height: 1.35;
      }
      #svgHost svg {
        width: 100%;
        max-width: 760px;
        height: auto;
        display: block;
      }
      .controls label {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 12px;
        align-items: center;
        margin: 10px 0;
      }
      .presets {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
        margin: 8px 0 0 0;
      }
      button {
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid #d1d5db;
        background: white;
        cursor: pointer;
        text-align: left;
      }
      button:hover { background: #f9fafb; }
      .download {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
        margin-top: 8px;
      }
      .error {
        color: #991b1b;
        background: #fef2f2;
        border: 1px solid #fecaca;
        padding: 10px 12px;
        border-radius: 10px;
        margin-top: 12px;
        font-size: 13px;
        line-height: 1.35;
      }
      .divider {
        height: 1px;
        background: #e5e7eb;
        margin: 14px 0;
      }

      /* Toggle (Segmented Control) */
      .toggle {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin: 8px 0 0 0;
      }
      .toggle button {
        text-align: center;
        font-weight: 600;
      }
      .toggle button[aria-pressed='true'] {
        border-color: #111827;
        background: #111827;
        color: #ffffff;
      }

      /* Responsive: bei Portrait oder schmalen Screens Sidebar nach unten */
      @media (orientation: portrait), (max-width: 900px) {
        .wrap { grid-template-columns: 1fr; }
        body { margin: 16px; }
        #svgHost svg { max-width: 100%; }
      }
    </style>
  </head>

  <body>
    <div class='wrap'>
      <div class='card'>
        <h1>Logo-Farbvarianten</h1>
        <div class='muted'>
          Dieses Tool lässt Sie eine Farbvariante auswählen oder die Hauptfarben des Logos manuell anpassen.
          <div class='divider'></div>
        </div>

        <div id='svgHost' style='margin-top: 14px;'></div>
        <div id='errorBox' style='display:none;'></div>
      </div>

      <div class='card controls'>
        <h2>Logo-Auswahl</h2>
        <div class='toggle' id='logoVariantToggle' role='group' aria-label='Logo-Auswahl'>
          <button id='btnLogoA' type='button' aria-pressed='true'>Variante A</button>
          <button id='btnLogoB' type='button' aria-pressed='false'>Variante B</button>
        </div>

        <h2>Farb-Auswahl</h2>
        <div class='muted'>
          Positiv = für hellen Hintergrund, Negativ = für dunklen Hintergrund.
        </div>
        <div class='toggle' id='polarityToggle' role='group' aria-label='Positiv oder Negativ'>
          <button id='btnPos' type='button' aria-pressed='true'>Positiv</button>
          <button id='btnNeg' type='button' aria-pressed='false'>Negativ</button>
        </div>

        <label>Hell <input id='colorBright' type='color' value='#F7C51D' /></label>
        <label>Dunkel <input id='colorDark' type='color' value='#25386C' /></label>
        <label>Akzent <input id='colorHighlight' type='color' value='#EC2027' /></label>

        <h2>Farbvarianten (Voreinstellungen)</h2>
        <div class='presets' id='presets'></div>

        <h2>Download</h2>
        <div class='muted' id='downloadHint'></div>
        <div class='download'>
          <button id='downloadPng' type='button'>Bild herunterladen</button>
        </div>
      </div>
    </div>

    <script>
      // Diese "Originalfarben" müssen den Farben entsprechen, die im jeweiligen SVG tatsächlich vorkommen,
      // damit das Ersetzen (Recolor) funktioniert.
      const ORIGINAL_BY_POLARITY = {
        pos: {
          bright: '#F7C51D',
          dark: '#24376c',
          highlight: '#EC2027',
        },
        neg: {
          bright: '#9ED1ED',
          dark: '#0F73B0',
          highlight: '#EC2027',
        },
      };

      // Startwerte für die Picker je Modus (kann der User danach frei anpassen).
      const DEFAULT_COLORS_BY_POLARITY = {
        pos: {
          bright: '#F7C51D',
          dark: '#24376c',
          highlight: '#EC2027',
        },
        neg: {
          bright: '#9ED1ED',
          dark: '#0F73B0',
          highlight: '#EC2027',
        },
      };

      // Automatische PNG-Groesse:
      // Die lange Kante (Breite oder Hoehe) wird auf diesen Wert skaliert.
      const TARGET_LONG_EDGE_PX = 1000;

      // PNG Hintergrund: immer weiss (wie gewünscht).
      const PNG_BACKGROUND = '#ffffff';

      const svgHost = document.getElementById('svgHost');
      const presetsEl = document.getElementById('presets');
      const errorBox = document.getElementById('errorBox');
      const downloadHint = document.getElementById('downloadHint');

      const inputBright = document.getElementById('colorBright');
      const inputDark = document.getElementById('colorDark');
      const inputHighlight = document.getElementById('colorHighlight');

      const btnLogoA = document.getElementById('btnLogoA');
      const btnLogoB = document.getElementById('btnLogoB');
      const btnPos = document.getElementById('btnPos');
      const btnNeg = document.getElementById('btnNeg');

      /** @type {SVGElement|null} */
      let svgEl = null;

      /** @type {string} */
      let originalSvgText = '';

      /** @type {{width: number, height: number}} */
      let exportSize = { width: TARGET_LONG_EDGE_PX, height: TARGET_LONG_EDGE_PX };

      /** @type {{variant: 'a'|'b', polarity: 'pos'|'neg'}} */
      const selection = { variant: 'a', polarity: 'pos' };

      // Merkt sich die zuletzt verwendeten Farben pro Modus (damit Pos/Neg unabhängig bleiben).
      /** @type {{pos: {bright: string, dark: string, highlight: string}, neg: {bright: string, dark: string, highlight: string}}} */
      const colorsByPolarity = {
        pos: {
          bright: inputBright.value,
          dark: inputDark.value,
          highlight: inputHighlight.value,
        },
        neg: {
          bright: DEFAULT_COLORS_BY_POLARITY.neg.bright,
          dark: DEFAULT_COLORS_BY_POLARITY.neg.dark,
          highlight: DEFAULT_COLORS_BY_POLARITY.neg.highlight,
        },
      };

      let loadToken = 0;

      function setPressed(el, pressed) {
        el.setAttribute('aria-pressed', pressed ? 'true' : 'false');
      }

      function clearError() {
        errorBox.style.display = 'none';
        errorBox.className = '';
        errorBox.textContent = '';
      }

      function showError(message) {
        errorBox.style.display = 'block';
        errorBox.className = 'error';
        errorBox.textContent = message;
      }

      function getLogoFilename() {
        // Erwartete Dateien:
        // logo_a_pos.svg, logo_a_neg.svg, logo_b_pos.svg, logo_b_neg.svg
        return `./logo_${selection.variant}_${selection.polarity}.svg`;
      }

      function getOriginalColors() {
        return ORIGINAL_BY_POLARITY[selection.polarity];
      }

      /**
       * @param {string} hex
       * @return {string}
       */
      function normalizeHex(hex) {
        if (!hex) return '';
        const v = hex.trim().toLowerCase();
        if (!v.startsWith('#')) return v;
        if (v.length === 4) {
          return `#${v[1]}${v[1]}${v[2]}${v[2]}${v[3]}${v[3]}`;
        }
        return v;
      }

      /**
       * Converts a CSS/SVG length to pixels (best effort).
       * Supports px, mm, cm, in, pt, pc. If unitless, assumes px.
       * @param {string} value
       * @return {number}
       */
      function lengthToPx(value) {
        if (!value) return 0;
        const v = value.trim().toLowerCase();
        const m = v.match(/^([0-9]*\.?[0-9]+)\s*(px|mm|cm|in|pt|pc)?$/);
        if (!m) return 0;
        const num = Number(m[1]);
        const unit = m[2] || 'px';

        if (unit === 'px') return num;
        if (unit === 'in') return num * 96;
        if (unit === 'cm') return (num / 2.54) * 96;
        if (unit === 'mm') return (num / 25.4) * 96;
        if (unit === 'pt') return (num / 72) * 96;
        if (unit === 'pc') return (num * 12 / 72) * 96;
        return 0;
      }

      /**
       * Basic CSV line parser supporting quoted fields.
       * @param {string} line
       * @param {string} delimiter
       * @return {!Array<string>}
       */
      function parseCsvLine(line, delimiter) {
        const out = [];
        let cur = '';
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
          const ch = line[i];
          if (ch === '"') {
            if (inQuotes && line[i + 1] === '"') {
              cur += '"';
              i++;
            } else {
              inQuotes = !inQuotes;
            }
          } else if (ch === delimiter && !inQuotes) {
            out.push(cur.trim());
            cur = '';
          } else {
            cur += ch;
          }
        }
        out.push(cur.trim());
        return out;
      }

      /**
       * Parses CSV (auto-detects ';' vs ',').
       * @param {string} csvText
       * @return {!Array<!Object<string, string>>}
       */
      function parseCsv(csvText) {
        const lines = csvText
          .split(/\r?\n/)
          .map((l) => l.trim())
          .filter((l) => l.length > 0);

        if (lines.length < 2) return [];

        const delimiter = lines[0].includes(';') ? ';' : ',';
        const headers = parseCsvLine(lines[0], delimiter).map((h) => h.trim());
        const rows = [];

        for (let i = 1; i < lines.length; i++) {
          const fields = parseCsvLine(lines[i], delimiter);
          const row = {};
          for (let j = 0; j < headers.length; j++) {
            row[headers[j]] = (fields[j] || '').trim();
          }
          rows.push(row);
        }
        return rows;
      }

      /**
       * Recolors SVG elements by matching fill/stroke/stop-color equal to one of original colors.
       * @param {!SVGElement} svg
       * @param {{bright: string, dark: string, highlight: string}} target
       */
      function recolorSvg(svg, target) {
        const original = getOriginalColors();
        const map = new Map([
          [normalizeHex(original.bright), normalizeHex(target.bright)],
          [normalizeHex(original.dark), normalizeHex(target.dark)],
          [normalizeHex(original.highlight), normalizeHex(target.highlight)],
        ]);

        const all = svg.querySelectorAll('*');
        for (const el of all) {
          for (const attr of ['fill', 'stroke', 'stop-color']) {
            const val = el.getAttribute(attr);
            if (!val) continue;

            const n = normalizeHex(val);
            if (map.has(n)) el.setAttribute(attr, map.get(n));
          }

          const style = el.getAttribute('style');
          if (style) {
            let updated = style;
            for (const [from, to] of map.entries()) {
              updated = updated.replaceAll(from, to);
            }
            if (updated !== style) el.setAttribute('style', updated);
          }
        }
      }

      function getCurrentColors() {
        return {
          bright: inputBright.value,
          dark: inputDark.value,
          highlight: inputHighlight.value,
        };
      }

      /**
       * Apply colors by re-injecting a clean SVG, then recoloring.
       * Also stores the colors for the current polarity.
       * @param {{bright: string, dark: string, highlight: string}} colors
       */
      function applyColors(colors) {
        inputBright.value = colors.bright;
        inputDark.value = colors.dark;
        inputHighlight.value = colors.highlight;

        colorsByPolarity[selection.polarity] = {
          bright: colors.bright,
          dark: colors.dark,
          highlight: colors.highlight,
        };

        if (!originalSvgText) return;

        svgHost.innerHTML = originalSvgText;
        svgEl = svgHost.querySelector('svg');
        if (!svgEl) return;

        recolorSvg(svgEl, colorsByPolarity[selection.polarity]);
      }

      /**
       * Computes export size from SVG (width/height preferred, else viewBox), scaled to TARGET_LONG_EDGE_PX.
       * @param {!SVGElement} svg
       * @return {{width: number, height: number}}
       */
      function computeExportSize(svg) {
        const wAttr = svg.getAttribute('width') || '';
        const hAttr = svg.getAttribute('height') || '';
        const wPx = lengthToPx(wAttr);
        const hPx = lengthToPx(hAttr);

        let baseW = 0;
        let baseH = 0;

        if (wPx > 0 && hPx > 0) {
          baseW = wPx;
          baseH = hPx;
        } else {
          const vb = svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal : null;
          if (vb && vb.width > 0 && vb.height > 0) {
            baseW = vb.width;
            baseH = vb.height;
          } else {
            baseW = 1000;
            baseH = 500;
          }
        }

        const longEdge = Math.max(baseW, baseH);
        const scale = Math.max(1, TARGET_LONG_EDGE_PX / longEdge);

        return {
          width: Math.max(1, Math.round(baseW * scale)),
          height: Math.max(1, Math.round(baseH * scale)),
        };
      }

      function serializeSvg(svg) {
        const clone = svg.cloneNode(true);
        if (!clone.getAttribute('xmlns')) {
          clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        }
        if (!clone.getAttribute('xmlns:xlink')) {
          clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
        }
        const serializer = new XMLSerializer();
        return `<?xml version='1.0' encoding='UTF-8'?>\n${serializer.serializeToString(clone)}`;
      }

      function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 2000);
      }

      function svgTextToPngBlob(svgText, width, height) {
        return new Promise((resolve, reject) => {
          const svgBlob = new Blob([svgText], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(svgBlob);

          const img = new Image();
          img.decoding = 'async';

          img.onload = () => {
            try {
              const canvas = document.createElement('canvas');
              canvas.width = width;
              canvas.height = height;

              const ctx = canvas.getContext('2d');

              // Weisser Hintergrund.
              ctx.fillStyle = PNG_BACKGROUND;
              ctx.fillRect(0, 0, width, height);

              ctx.drawImage(img, 0, 0, width, height);

              canvas.toBlob((blob) => {
                URL.revokeObjectURL(url);
                if (!blob) {
                  reject(new Error('PNG konnte nicht erstellt werden.'));
                  return;
                }
                resolve(blob);
              }, 'image/png');
            } catch (err) {
              URL.revokeObjectURL(url);
              reject(err);
            }
          };

          img.onerror = () => {
            URL.revokeObjectURL(url);
            reject(new Error('SVG konnte nicht in ein Bild geladen werden.'));
          };

          img.src = url;
        });
      }

      async function loadLogoForSelection() {
        const token = ++loadToken;
        clearError();

        const filename = getLogoFilename();
        const res = await fetch(filename, { cache: 'no-store' });
        if (!res.ok) throw new Error(`${filename} konnte nicht geladen werden (HTTP ${res.status}).`);
        const text = await res.text();

        if (token !== loadToken) return;

        originalSvgText = text;
        svgHost.innerHTML = originalSvgText;
        svgEl = svgHost.querySelector('svg');
        if (!svgEl) throw new Error(`${filename} enthaelt kein <svg>-Root-Element.`);

        exportSize = computeExportSize(svgEl);

        downloadHint.textContent =
          `Hier kann das Logo mit eingestellten Farben heruntergeladen werden (${exportSize.width} × ${exportSize.height} px).`;

        // Wichtig: nach dem Laden die gespeicherten Farben des aktuellen Modus anwenden.
        const colors = colorsByPolarity[selection.polarity] || DEFAULT_COLORS_BY_POLARITY[selection.polarity];
        applyColors(colors);
      }

      async function loadPalettes() {
        const res = await fetch('./palettes.csv', { cache: 'no-store' });
        if (!res.ok) throw new Error(`palettes.csv konnte nicht geladen werden (HTTP ${res.status}).`);
        const csvText = await res.text();
        return parseCsv(csvText);
      }

      function renderPaletteButtons(rows) {
        presetsEl.innerHTML = '';

        for (const row of rows) {
          const variant = (row.variant || '').trim();
          const name = (row.name || '').trim();
          const bright = (row.bright || '').trim();
          const dark = (row.dark || '').trim();
          const highlight = (row.highlight || '').trim();

          if (!bright || !dark || !highlight) continue;

          const btn = document.createElement('button');
          btn.type = 'button';
          btn.textContent = variant ? `${variant}  ${name}` : name;

          btn.addEventListener('click', () => {
            // Presets sollen immer die aktuellen (Pos/Neg) Zielwerte setzen.
            applyColors({ bright, dark, highlight });
          });

          presetsEl.appendChild(btn);
        }
      }

      // Toggle Events
      btnLogoA.addEventListener('click', async () => {
        selection.variant = 'a';
        setPressed(btnLogoA, true);
        setPressed(btnLogoB, false);
        try { await loadLogoForSelection(); } catch (err) { showError(String(err)); }
      });

      btnLogoB.addEventListener('click', async () => {
        selection.variant = 'b';
        setPressed(btnLogoA, false);
        setPressed(btnLogoB, true);
        try { await loadLogoForSelection(); } catch (err) { showError(String(err)); }
      });

      btnPos.addEventListener('click', async () => {
        if (selection.polarity === 'pos') return;

        // Aktuelle Negativ-Farben speichern
        colorsByPolarity.neg = getCurrentColors();

        selection.polarity = 'pos';
        setPressed(btnPos, true);
        setPressed(btnNeg, false);

        // Positiv-Farben wiederherstellen
        const colors = colorsByPolarity.pos || DEFAULT_COLORS_BY_POLARITY.pos;
        applyColors(colors);

        try { await loadLogoForSelection(); } catch (err) { showError(String(err)); }
      });

      btnNeg.addEventListener('click', async () => {
        if (selection.polarity === 'neg') return;

        // Aktuelle Positiv-Farben speichern
        colorsByPolarity.pos = getCurrentColors();

        selection.polarity = 'neg';
        setPressed(btnPos, false);
        setPressed(btnNeg, true);

        // Negativ-Farben setzen (oder Defaults beim ersten Mal)
        const colors = colorsByPolarity.neg || DEFAULT_COLORS_BY_POLARITY.neg;
        applyColors(colors);

        try { await loadLogoForSelection(); } catch (err) { showError(String(err)); }
      });

      // Picker changes.
      document.addEventListener('input', (e) => {
        if (e.target !== inputBright && e.target !== inputDark && e.target !== inputHighlight) return;
        applyColors(getCurrentColors());
      });

      document.getElementById('downloadPng').addEventListener('click', async () => {
        if (!svgEl) return;

        try {
          const svgText = serializeSvg(svgEl);
          const blob = await svgTextToPngBlob(svgText, exportSize.width, exportSize.height);

          const variantLabel = selection.variant.toUpperCase();
          const polLabel = selection.polarity;
          downloadBlob(blob, `bsg-reinach-logo-${variantLabel}-${polLabel}-${exportSize.width}x${exportSize.height}.png`);
        } catch (err) {
          showError(String(err));
        }
      });

      async function init() {
        try {
          const rows = await loadPalettes();
          renderPaletteButtons(rows);

          // Optional: erste Palette direkt anwenden (auf Positiv-Start).
          if (rows.length > 0) {
            const first = rows[0];
            if (first.bright && first.dark && first.highlight) {
              colorsByPolarity.pos = {
                bright: first.bright.trim(),
                dark: first.dark.trim(),
                highlight: first.highlight.trim(),
              };
              applyColors(colorsByPolarity.pos);
            }
          }

          await loadLogoForSelection();
        } catch (err) {
          showError(String(err));
        }
      }

      init();
    </script>
  </body>
</html>
